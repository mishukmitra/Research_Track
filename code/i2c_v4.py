# I2C communication between pi and xsens & measuring live motion data using Push button and LED
#
# References:
# https://cdn2.hubspot.net/hubfs/3446270/Downloads/Manuals/Hardware_Integration_Manual_MTi_1-series.pdf						(link:1)
# https://cdn2.hubspot.net/hubfs/3446270/Downloads/Leaflets/MTi-1-series-datasheet.pdf										(link:2)
# https://1drv.ms/b/s!AqtCaRJTR76vymVlSyjQYkbMKXnQ?e=ob6zoP			(link:3)
# https://base.xsens.com/hc/en-us/articles/115002856865-Best-practices-I2C-and-SPI-for-MTi-1-series?mobile_site=true		(link:4)
# https://1drv.ms/b/s!AqtCaRJTR76vsw1RJycZP2z9RCGO?e=eQnXgK 		(link:5)
#
# Max i2c speed of pi 400Kbps. We want to read values with 100hz (by default sensor give values 100 times in 1 seconds), then we need max speed for i2c = 400Kbps 
# We need setup raspberry to use i2c with speed 400 Kbps. 
#  1. open lxterminal
#  2. type: sudo nano /boot/config.txt
#  3. add line: i2c_arm_baudrate=400000 
#  4. save and close file: ctrl+x, y, enter
#
# To run this program type in lxterminal: "sudo python i2c.py"  
# Values from sensor will be saved in a file: "/home/pi/data.txt". Use to see values next command: "tail -f /home/pi/data.txt" 

import RPi.GPIO  as GPIO		# general purpose input output (Switch: pin 10 (gpio-15) to switch and switch to 240 ohm to 3.3v / LED: pin 12 (gpio-18) to 120 ohm to LED and other end to ground)
import time						# this is for make dalay (sleep) 
import io						
import fcntl					# This module performs file control and I/O control on file descriptors.
import sys
import struct					# for make float from 4 byte
import os
from datetime import datetime  	# we will write time to file 

ADR1		=	0x6b;						# address of sensors in i2c bus
ADR2		=	0x6a;
I2C_SLAVE	=	0x0703;  				# it is hardcoded in unix system constant. the file used like i2c device in slave mode. (this used in ioctl. from linux/i2c-dev.h)

OPCODE_CONTROLPIPE      =   0x03;  # Used to send control messages to the module (link:5, Page:11)
OPCODE_PIPESTATUS       =   0x04;  # Provides status information for the read pipes (link:5, Page:11)
OPCODE_NOTIFICATIONPIPE =   0x05;  # Used to read non-measurement data: errors acknowledgements and other notifications from the module (link:5, Page:11)
OPCODE_MEASUREMENTPIPE  =   0x06;  # All measurement data generated by the module will be available in the measurement pipe (link:5, Page:11)

MID_GOTOCONFIG          =   0x30;  # MessageID: GoToConfig (link:3, Page:11)
MID_GOTOMEASUREMENT     =   0x10;  # MessageID: GoToMeasurement (link:3, Page:11)
MID_RESET               =   0x40;  #  (link:3, Page:56)
MID_SETCONFIG           =   0xC0;  # Set the current output configuration (link:3, Page:23)
MTData2					=   54 	   # (0x36) # Message with one or more output data packets (link:3, Page:59)

PacketCounter 			=	0x1020 # (link:3, Page:52)
SampleTimeFine 			=	0x1060 # (link:3, Page:52)
Acceleration			=	0x4020 # (link:3, Page:52)
Rate_of_Turn			=	0x8020 # (link:3, Page:52)
Magnetic_Field			=	0xC020 # (link:3, Page:52)
Quaternion				=	0x2010 # (link:3, Page:52)
Statusword				=	0xE020 # (link:3, Page:52)


##----------Creating i2c class to read, write, create, close (say to the system that this file is a i2c device) ---------
class i2c:						# create class for working i2c, we work with it like with file, because library SMBus can not read and write array more than 32 bytes, but we need read and write array more than 32 bytes
	def __init__(self, device, bus):
		self.fr = io.open("/dev/i2c-"+str(bus), "rb", buffering=0) # create description for read
		self.fw = io.open("/dev/i2c-"+str(bus), "wb", buffering=0) # create description for write
		fcntl.ioctl(self.fr, I2C_SLAVE, device) # speak that it I2C SLAVE device
		fcntl.ioctl(self.fw, I2C_SLAVE, device) # speak that it I2C SLAVE device
		time.sleep(1)
	def read(self, count):
		return self.fr.read(count) 	# count bytes from i2c file
	def write(self, data):
		if type(data) is list:
			data = bytearray(data)
		elif type(data) is str:
			data = _b(data)
		self.fw.write(data)			# read data from i2c file	
	def close(self):
		self.fr.close()				# close two i2c files
		self.fw.close()
#----------------------------------------------------------------------------------------

##-----------Initialization and configuration-----------------------------------------
def sensor_init(d):
    	# First: we send to sensor is 'RESET'
	d.write([OPCODE_CONTROLPIPE, MID_RESET, 0, 193]) 	# Send "reset (0x40)" to ControlPipe. 0 - lenght of parameters. 193 - checksum for this message ....
		# i2c always use address opcode instead BID. when we use write function first byte set from opcode 
		# see checksum_calculation code for getting checksum for specific message
    	time.sleep(1);			   	# mti-1 needs time after reset, wait 1 secomd
    	# Second: waiting for WakeUp. in this loop we must read notifications from sensor. when we catch 62 (0x3E) (WakeUp) - it means that sensor was reset and boot
	for i in range(300): 	   	# 300 in the loop and in the end time sleep 0.1s (300*0.1 =30s). Max time to wake up for the loop will be 30s.
								# But we really go out from this loop faster when catch WakeUp and then break. SO any values can be used instead 300
        	pipes_len=0		# lenght for notification
        	pipem_len=0		# lenght for measures
        	try:
            		d.write([OPCODE_PIPESTATUS])		# we work with PipeStatus(4) to know how many bytes we must read (link:5, Page:11)
            		s = d.read(4) 	# now we read 4 bytes to know lenght of massages.
            		t = bytearray()		# create new empy array of bytes
                	t.extend(map(ord, s)) # S is string, byt we need bytes
                	pipes_len=t[0]+(t[1]*256); # 1st and 2nd bytes are lenght of  NotificationPipe
                	pipem_len=t[2]+(t[3]*256); # 3th and 4th bytes are lenght of  MeasurementPipe
            		d.write([OPCODE_NOTIFICATIONPIPE])		# we work with NotificationPipe(5) (link:5, Page:11)
               	 	s = d.read(pipes_len); # read NotificationPipe. S is string, byt we need bytes
                	t = bytearray()	# create new emtpy array of bytes
                	t.extend(map(ord, s))	# making it to bytes
            		print(hex(t[0]))	# print MID from notification
			if (t[0]==0x41):
				print("ResetAck catched")
            		if (t[0]==62):		# if it 0x3E = WakeUp (link:3, Page:56). then go out from this loop
                		print("WakeUp catched")
                		break;
            		if (t[0]==0x42):
				print("error: "+hex(t[1])+" "+hex(t[2]))
				d.write([OPCODE_CONTROLPIPE, MID_RESET, 0, 193]) 
				time.sleep(0.5);
				d.write([OPCODE_CONTROLPIPE,MID_GOTOCONFIG,0,209]) 
			if (t[0]==0x31):
				print("ConfigModeAck catched")
				break;
			#dev.write([OPCODE_CONTROLPIPE ,63,0,194]) # wakeupAck = 63 (0x3F) (link:3, Page:56)
			#d.write([OPCODE_MEASUREMENTPIPE])		# we work with MeasurementPipe(6) (link:5, Page:11)
            		#s=d.read(pipem_len) # read MeasurementPipe, but we need this Measure, just read
        	except:
            		print("E")
        	time.sleep(0.1)
    	time.sleep(0.2)
    	# Third: Put sensor to Configure state
	d.write([OPCODE_CONTROLPIPE,MID_GOTOCONFIG,0,209])  # goto Config mode
    	time.sleep(0.2)
    	# Fourth: Set configuration for sensor: Acc, Gyr, Mag and Quaternion refresh 1 time in 1 second (link:3, Page:52)
	d.write([OPCODE_CONTROLPIPE,MID_SETCONFIG,28,0x10,0x20,0xff,0xff,0x10,0x60,0xff,0xff,0x40,0x20,0,1,0x80,0x20,0,1,0xc0,0x20,0,1,0x20,0x10,0,1,0xe0,0x20,0xff,0xff,119]) 
    	time.sleep(0.2)
#---------------------------------------------------------------------------------------

##----------Sensor Get Measure-----------------------------------------------------------
def sensor_get_measure(dev, num, write):
	s="";
	pipes_len=0
	pipem_len=0
	try:
		dev.write([OPCODE_PIPESTATUS])		# we work with PipeStatus(4) to know how many bytes we must read (3th link page 11)
		s = dev.read(4)		# now we read 4 bytes to know lenght of massages.
		t = bytearray()	# create new emtpy array of bytes
		t.extend(map(ord, s)) # making it to bytes
		#print("\r\n4. PipeStatus: %x %x   %x %x" %(t[0], t[1], t[2], t[3]));
		pipes_len=t[0]+(t[1]*256); # 2 bytes are the length of the notification pipe
		pipem_len=t[2]+(t[3]*256); # 2 bytes are the length of measurement 
	except:
		if (write == 1): 
	                print("error")
	if (pipes_len>0):
		if (write == 1): 
       			print "\r\n5. Notification: ",
		dev.write([OPCODE_NOTIFICATIONPIPE])				# we work with NotificationPipe(5) (link:5, Page:11)
		s = dev.read(pipes_len);	# read NotificationPipe. S is string, byt we need bytes
		t = bytearray() # create new emtpy array of bytes
		t.extend(map(ord, s)) # making it to bytes
		for i in range(pipes_len):	# print Notification
			if (write == 1): 
                		print hex(t[i]),
	if (pipem_len>0):
		dev.write([OPCODE_MEASUREMENTPIPE])				# we work with MeasurementPipe(6) (link:5, Page:11)
		s =  dev.read(pipem_len)	# read MeasurementPipe. S is string, byt we need bytes
		t = bytearray() # create new emtpy array of bytes
		t.extend(map(ord, s)) # making it to bytes
		sum=0
		for i in range(pipem_len):  # make checkSum of message
			sum=sum+t[i];
		if ((sum%256)==1):			# and check it
			if (write == 1): 
		                print("CheckSum is correct")
		if (t[0]==0x36):			# MtData2 is MID 0x36, we need it
			if (write == 1): 
                		#print(chr(27) + "[2J")	# clear output
		        	print("\r\nWe have MtData2 message")
                		zf=open("/home/pi/data.txt", 'a')	# open file to save values
                		zf.write(num+str(datetime.now())+"\r\n")# write data and time to file
			#-------------------
			k=2; # k is our position of bytes in message
			while (k<t[1]): # read byte after byte if it more than lenght in message
				xdi=t[k]*256+t[k+1];	# make XDI from 2 bytes
				k=k+1;
				if (xdi == 0x1020):   	#  0x1020 = PacketCounter
					cnt=t[k+2]*256+t[k+3]
					if (write == 1): 
                        			print("PacketCounter = "+str(cnt))
					k=k+4
				elif (xdi == 0x1060):	#  0x1060 = Sample time fine
					if (write == 1): 
                        			print("Sample time fine")
					k=k+6
				elif (xdi == 0x2010):	#  0x2010 = Quaternion
					k=k+1
                			dd1 = bytearray([t[k+1], t[k+2], t[k+3], t[k+4]])
                    			d1= struct.unpack('>f', dd1) # make float from bytes array 
					dd2 = bytearray([t[k+5], t[k+6], t[k+7], t[k+8]])
                    			d2= struct.unpack('>f', dd2) # make float from bytes array 
					dd3 = bytearray([t[k+9], t[k+10], t[k+11], t[k+12]])
                    			d3= struct.unpack('>f', dd3) # make float from bytes array 
					dd4 = bytearray([t[k+13], t[k+14], t[k+15], t[k+16]])
					d4 = struct.unpack('>f', dd4)
					if (write == 1): 
                        			print(num+"Quaternion: "+str(d1)+" "+str(d2)+" "+str(d3)+" "+str(d4)) # print to output
                        			zf.write(num+"Quaternion: "+str(d1)+"   "+str(d2)+"   "+str(d3)+" "+str(d4)+"\r\n")       # print to file
					k=k+17
				elif (xdi == 0x8030):	#  0x8030 = DeltaQ
					if (write == 1): 
                        			print("DeltaQ: not need")
					k=k+18
				elif (xdi == 0xe020):	#  0xe020 = Status word (4 bytes)
					w=t[k+2]*256*256*256+t[k+3]*256*256+t[k+4]*256+t[k+5];
					if (write == 1): 
                        			print("Status word: "+hex(w))
					k=k+6
					if (write == 1): 
                        			zf.close() 			# close file because it is last field
				elif (xdi == 0xc020):	#  0xc020 = Magnetic
					k=k+1
					dd1 = bytearray([t[k+1], t[k+2], t[k+3], t[k+4]])
					d1= struct.unpack('>f', dd1)  	# make float from bytes array
					dd2 = bytearray([t[k+5], t[k+6], t[k+7], t[k+8]])
					d2= struct.unpack('>f', dd2)	# make float from bytes array	
					dd3 = bytearray([t[k+9], t[k+10], t[k+11], t[k+12]])
					d3= struct.unpack('>f', dd3)  	# make float from bytes array
					if (write == 1): 
                        			print(num+"Magnetic: "+str(d1)+"   "+str(d2)+"   "+str(d3))				# print to output
                        			zf.write(num+"Magnetic: "+str(d1)+"   "+str(d2)+"   "+str(d3)+"\r\n")	# print to file
					k=k+13
				elif (xdi == 0x4020):	#  0x4020 = Acceleration 
					k=k+1
					dd1 = bytearray([t[k+1], t[k+2], t[k+3], t[k+4]])
					d1= struct.unpack('>f', dd1)  	# make float from bytes array
					dd2 = bytearray([t[k+5], t[k+6], t[k+7], t[k+8]])
					d2= struct.unpack('>f', dd2)  	# make float from bytes array
					dd3 = bytearray([t[k+9], t[k+10], t[k+11], t[k+12]])
					d3= struct.unpack('>f', dd3)  	# make float from bytes array
					if (write == 1): 
                        			print(num+"Acceleration: "+str(d1)+" "+str(d2)+" "+str(d3))				 # print to output
                        			zf.write(num+"Acceleration: "+str(d1)+"   "+str(d2)+"   "+str(d3)+"\r\n")# print to file
					k=k+13
				elif (xdi == 0x8020):	#  0x8020 = RateOfTurn
					k=k+1
					dd1 = bytearray([t[k+1], t[k+2], t[k+3], t[k+4]])
					d1= struct.unpack('>f', dd1)  	# make float from bytes array
					dd2 = bytearray([t[k+5], t[k+6], t[k+7], t[k+8]])
					d2= struct.unpack('>f', dd2)  	# make float from bytes array
					dd3 = bytearray([t[k+9], t[k+10], t[k+11], t[k+12]])
					d3= struct.unpack('>f', dd3)  	# make float from bytes array
					if (write == 1): 
                        			print(num+"RateOfTurn: "+str(d1)+" "+str(d2)+" "+str(d3))				# print to output
                        			zf.write(num+"RateOfTurn: "+str(d1)+"   "+str(d2)+"   "+str(d3)+"\r\n") # print to file
					k=k+13
				elif (xdi == 0x4010):	#  0x4010 = DeltaV
					if (write == 1): 
                        			print("DeltaV: not need")
					k=k+14
				else:
					if (write == 1): 
                        			print("unknown xdi: "+hex(xdi))
#-----------------------------------------------------------------------------------------

##----------open i2c bus------------------------------------------------------------------
dev1 = i2c(ADR1,1)
dev2 = i2c(ADR2,1)
sensor_init(dev1)
sensor_init(dev2)
#------------------------------------------------------------------------------------------
##----------Fifth: Put sensor to Measure mode ---------------------------------------------	
dev1.write([OPCODE_CONTROLPIPE,MID_GOTOMEASUREMENT,0,241])  # goto measure mode for sensor1
dev2.write([OPCODE_CONTROLPIPE,MID_GOTOMEASUREMENT,0,241])  # goto measure mode for sensor2
#--------init LED and BUTTON---------------------------------------------------------------
GPIO.setwarnings(False)
GPIO.setmode(GPIO.BOARD)
GPIO.setup(10, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
GPIO.setup(12, GPIO.OUT)
print("-------------------STOP MODE-------------------")
need_wr = 0;
GPIO.output(12, GPIO.LOW)
# infinity loop
while True:
	if (GPIO.input(10) == GPIO.HIGH):
        	if (need_wr == 0):
            		print("-------------------START MODE-------------------")
            		need_wr = 1;
            		GPIO.output(12, GPIO.HIGH)
        	else:
            		print("-------------------STOP MODE-------------------")
            		need_wr = 0;
            		GPIO.output(12, GPIO.LOW)
        	time.sleep(0.5)
	time.sleep(0.1) # we read PipeStatus 5 time in second
    	sensor_get_measure(dev1, "Sensor1 ", need_wr)
    	time.sleep(0.1)
    	sensor_get_measure(dev2, "Sensor2 ", need_wr)
dev1.close()
dev2.close()
#------------------------------------------------------------------------------------------
